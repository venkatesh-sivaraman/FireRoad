//
//  User.swift
//  FireRoad
//
//  Created by Venkatesh Sivaraman on 5/2/17.
//  Copyright Â© 2017 Base 12 Innovations. All rights reserved.
//

import UIKit

enum SubjectRating {
    static let baselineInCourseroad = 2
    static let baselineFavorites = 3
    static let baselineInCourseOfStudy = 1
    static let none = 0
}

enum UserSemester: Int {
    case PreviousCredit = 0
    case FreshmanFall = 1
    case FreshmanIAP = 2
    case FreshmanSpring = 3
    case SophomoreFall = 4
    case SophomoreIAP = 5
    case SophomoreSpring = 6
    case JuniorFall = 7
    case JuniorIAP = 8
    case JuniorSpring = 9
    case SeniorFall = 10
    case SeniorIAP = 11
    case SeniorSpring = 12
    
    func toString() -> String {
        switch self {
        case .PreviousCredit: return "Prior Credit"
        case .FreshmanFall: return "1st Year Fall"
        case .FreshmanIAP: return "1st Year IAP"
        case .FreshmanSpring: return "1st Year Spring"
        case .SophomoreFall: return "2nd Year Fall"
        case .SophomoreIAP: return "2nd Year IAP"
        case .SophomoreSpring: return "2nd Year Spring"
        case .JuniorFall: return "3rd Year Fall"
        case .JuniorIAP: return "3rd Year IAP"
        case .JuniorSpring: return "3rd Year Spring"
        case .SeniorFall: return "4th Year Fall"
        case .SeniorIAP: return "4th Year IAP"
        case .SeniorSpring: return "4th Year Spring"
        }
    }
    
    func isIAP() -> Bool {
        return (self == .FreshmanIAP || self == .SophomoreIAP || self == .JuniorIAP || self == .SeniorIAP)
    }
    
    func isFall() -> Bool {
        return (self == .FreshmanFall || self == .SophomoreFall || self == .JuniorFall || self == .SeniorFall)
    }
    
    func isSpring() -> Bool {
        return (self == .FreshmanSpring || self == .SophomoreSpring || self == .JuniorSpring || self == .SeniorSpring)
    }
    
    static let allEnrolledSemesters: [UserSemester] = [
        .FreshmanFall, .FreshmanIAP, .FreshmanSpring,
        .SophomoreFall, .SophomoreIAP, .SophomoreSpring,
        .JuniorFall, .JuniorIAP, .JuniorSpring,
        .SeniorFall, .SeniorIAP, .SeniorSpring
    ]
    
    static let allSemesters: [UserSemester] = [
        .PreviousCredit, .FreshmanFall, .FreshmanIAP, .FreshmanSpring,
        .SophomoreFall, .SophomoreIAP, .SophomoreSpring,
        .JuniorFall, .JuniorIAP, .JuniorSpring,
        .SeniorFall, .SeniorIAP, .SeniorSpring
    ]
}

class User: NSObject {
    
    private var selectedSubjects: [UserSemester: [Course]] = [:]
    
    var name: String = "No Name"
    /// Courses of study correspond to the filenames of .reql files.
    var coursesOfStudy: [String] = []
    
    var filePath: String? {
        didSet {
            if filePath != oldValue {
                needsSave = true
            }
            if saveTimer?.isValid == true {
                saveTimer?.invalidate()
            }
            if !readOnly {
                saveTimer = Timer.scheduledTimer(withTimeInterval: saveInterval, repeats: true, block: { _ in
                    self.autosave()
                })
            }
        }
    }
    var needsSave = false
    var readOnly = false
    private var saveInterval = 2.0
    private var saveTimer: Timer?
    
    var allCourses: [Course] {
        var ret: [Course] = []
        for (_, subjects) in selectedSubjects.sorted(by: { $0.key.rawValue < $1.key.rawValue }) {
            ret += subjects
        }
        return ret
    }
    
    init(contentsOfFile path: String, readOnly: Bool = false) throws {
        super.init()
        self.readOnly = readOnly
        try readUserCourses(from: path)
    }
    
    deinit {
        if saveTimer?.isValid == true {
            saveTimer?.invalidate()
        }
        NotificationCenter.default.removeObserver(self)
    }
    
    override init() {
        super.init()
    }
    
    func courses(forSemester semester: UserSemester) -> [Course] {
        if selectedSubjects.contains(where: { $0.0 == semester }) {
            return selectedSubjects[semester]!
        }
        return []
    }
    
    func delete(_ course: Course, fromSemester semester: UserSemester, removingOverrides: Bool = true) {
        var semesterCourses = self.courses(forSemester: semester)
        if let delIdx = semesterCourses.index(of: course) {
            semesterCourses.remove(at: delIdx)
        }
        self.selectedSubjects[semester] = semesterCourses
        if removingOverrides {
            overrides[course] = nil
        }
        setNeedsSave()
        
        if CourseManager.shared.userRatings[course.subjectID!] == nil {
            CourseManager.shared.setUserRatings([course.subjectID!: SubjectRating.none], autoGenerated: true)
        }
    }
    
    func add(_ course: Course, toSemester destSemester: UserSemester) {
        var semesterCourses = self.courses(forSemester: destSemester)
        if !semesterCourses.contains(course) {
            semesterCourses.append(course)
        }
        self.selectedSubjects[destSemester] = semesterCourses
        setNeedsSave()
        
        // Index the new department for Spotlight
        if let code = course.subjectCode {
            CourseManager.shared.indexSearchableItems(forDepartment: code)
        }
    }
    
    func insert(_ course: Course, toSemester destSemester: UserSemester, atIndex idx: Int) {
        var semesterCourses = self.courses(forSemester: destSemester)
        if !semesterCourses.contains(course) {
            semesterCourses.insert(course, at: min(idx, semesterCourses.count))
        }
        self.selectedSubjects[destSemester] = semesterCourses
        setNeedsSave()
        
        // Index the new department for Spotlight
        if let code = course.subjectCode {
            CourseManager.shared.indexSearchableItems(forDepartment: code)
        }
    }
    
    func move(_ course: Course, fromSemester semester: UserSemester, toSemester destSemester: UserSemester, atIndex idx: Int) {
        self.delete(course, fromSemester: semester, removingOverrides: false)
        self.insert(course, toSemester: destSemester, atIndex: idx)
        setNeedsSave()
    }
    
    @objc func courseManagerFinishedLoading() {
        for (semester, courses) in selectedSubjects {
            selectedSubjects[semester] = courses.map({ CourseManager.shared.getCourse(withID: $0.subjectID!) ?? $0 })
        }
        warningsCache.removeAll()
        var newOverrides: [Course: Bool] = [:]
        for (course, over) in overrides {
            guard let newCourse = CourseManager.shared.getCourse(withID: course.subjectID!) else {
                continue
            }
            newOverrides[newCourse] = over
        }
        overrides = newOverrides
    }
    
    // MARK: - Courses of Study
    
    func addCourseOfStudy(_ listID: String) {
        coursesOfStudy.append(listID)
        if let reqList = RequirementsListManager.shared.requirementList(withID: listID) {
            var newRatings: [String: Int] = [:]
            for course in reqList.requiredCourses where course.subjectID != nil {
                if CourseManager.shared.userRatings[course.subjectID!] == nil {
                    newRatings[course.subjectID!] = SubjectRating.baselineInCourseOfStudy
                }
            }
            CourseManager.shared.setUserRatings(newRatings, autoGenerated: true)
        }
        setNeedsSave()
    }
    
    func removeCourseOfStudy(_ listID: String) {
        if let index = coursesOfStudy.index(of: listID) {
            coursesOfStudy.remove(at: index)
            if let reqList = RequirementsListManager.shared.requirementList(withID: listID) {
                var newRatings: [String: Int] = [:]
                for course in reqList.requiredCourses where course.subjectID != nil {
                    if CourseManager.shared.userRatings[course.subjectID!] == nil {
                        newRatings[course.subjectID!] = SubjectRating.none
                    }
                }
                CourseManager.shared.setUserRatings(newRatings, autoGenerated: true)
            }
            setNeedsSave()
        }
    }
    
    // MARK: - Courseroad Error Checking
    
    enum CourseWarningType: String {
        case unsatisfiedPrerequisites = "Unsatisfied Prerequisite"
        case unsatisfiedCorequisites = "Unsatisfied Corequisite"
        case notOffered = "Not Offered"
    }
    
    struct CourseWarning: Equatable {
        var type: CourseWarningType
        var message: String?
        
        static func ==(lhs: CourseWarning, rhs: CourseWarning) -> Bool {
            return lhs.type == rhs.type && lhs.message == rhs.message
        }
    }
    
    var warningsCache: [Course: [CourseWarning]] = [:]
    
    var overrides: [Course: Bool] = [:]
    
    func warningsForCourse(_ course: Course, in semester: UserSemester) -> [CourseWarning] {
        guard semester != .PreviousCredit else {
            return []
        }
        if let warnings = warningsCache[course] {
            return warnings
        }
        var unsatisfiedPrereqs: [String] = []
        for prereqList in course.prerequisites {
            var satisfied = false
            for prereq in prereqList {
                for otherSemester in UserSemester.allSemesters where otherSemester.rawValue < semester.rawValue {
                    for course in courses(forSemester: otherSemester) {
                        if course.satisfies(requirement: prereq) {
                            satisfied = true
                            break
                        }
                    }
                    if satisfied {
                        break
                    }
                }
                if !satisfied {
                    satisfied = Course.isRequirementAutomaticallySatisfied(prereq)
                }
                if satisfied {
                    break
                }
            }
            if !satisfied {
                unsatisfiedPrereqs += prereqList
            }
        }
        var unsatisfiedCoreqs: [String] = []
        for coreqList in course.corequisites {
            var satisfied = false
            for coreq in coreqList {
                for otherSemester in UserSemester.allSemesters where otherSemester.rawValue <= semester.rawValue {
                    for course in courses(forSemester: otherSemester) {
                        if course.satisfies(requirement: coreq) {
                            satisfied = true
                            break
                        }
                    }
                    if satisfied {
                        break
                    }
                }
                if !satisfied {
                    satisfied = Course.isRequirementAutomaticallySatisfied(coreq)
                }
                if satisfied {
                    break
                }
            }
            if !satisfied {
                unsatisfiedCoreqs += coreqList
            }
        }
        var warnings: [CourseWarning] = []
        if semester.isFall(), !course.isOfferedFall {
            warnings.append(CourseWarning(type: .notOffered, message: "According to the course catalog, \(course.subjectID!) is not offered in the fall."))
        } else if semester.isIAP(), !course.isOfferedIAP {
            warnings.append(CourseWarning(type: .notOffered, message: "According to the course catalog, \(course.subjectID!) is not offered over IAP."))
        } else if semester.isSpring(), !course.isOfferedSpring {
            warnings.append(CourseWarning(type: .notOffered, message: "According to the course catalog, \(course.subjectID!) is not offered in the spring."))
        }
        if unsatisfiedPrereqs.count > 0 {
            warnings.append(CourseWarning(type: .unsatisfiedPrerequisites, message: formatUnsatisfiedRequirements(label: "prerequisites", unsatisfiedItems: unsatisfiedPrereqs, requirements: course.prerequisites)))
        }
        if unsatisfiedCoreqs.count > 0 {
            warnings.append(CourseWarning(type: .unsatisfiedCorequisites, message: formatUnsatisfiedRequirements(label: "corequisites", unsatisfiedItems: unsatisfiedCoreqs, requirements: course.corequisites)))
        }
        warningsCache[course] = warnings
        return warnings
    }
    
    private func formatUnsatisfiedRequirements(label: String, unsatisfiedItems: [String], requirements: [[String]]) -> String {
        var message = "One or more \(label) is not satisfied"
        if requirements.count == requirements.flatMap({ $0 }).count {
            var prereqStrings = unsatisfiedItems
            if prereqStrings.count >= 2 {
                prereqStrings[prereqStrings.count - 1] = "and " + prereqStrings[prereqStrings.count - 1]
            }
            message += ": " + prereqStrings.joined(separator: ", ") + "."
        } else if requirements.count == 1 {
            var prereqStrings = unsatisfiedItems
            if prereqStrings.count >= 2 {
                prereqStrings[prereqStrings.count - 1] = "or " + prereqStrings[prereqStrings.count - 1]
            }
            message += ": " + prereqStrings.joined(separator: ", ") + "."
        } else {
            message += "."
        }
        return message
    }
    
    func overridesWarnings(for course: Course) -> Bool {
        return overrides[course] ?? false
    }
    
    func setOverridesWarnings(_ override: Bool, for course: Course) {
        overrides[course] = override
        setNeedsSave()
    }
    
    // MARK: - Global Relevance Calculation
    
    private enum RelevanceCacheType: Int {
        case plannedSubjects
        case ratedSubjects
        case majorSubjects
        case nonMajorSubjects
        case primaryRelatedSubjects
    }
    private var relevanceCache: [RelevanceCacheType: [Course: Float]] = [:]
    
    private static let relevanceCacheWeights: [RelevanceCacheType: Float] = [
        .plannedSubjects: 2.0,
        .ratedSubjects: 2.0,    //In the future, weight this by rating
        .majorSubjects: 4.0,
        .nonMajorSubjects: 3.0,
        .primaryRelatedSubjects: 0.1   //Because it is going to be additionally weighted by relevance
    ]
    
    private func addCourse(_ course: Course, toRelevanceCache cache: RelevanceCacheType, weight: Float = 1.0) {
        if let oldValue = relevanceCache[cache]?[course] {
            relevanceCache[cache]?[course]? = max(oldValue, User.relevanceCacheWeights[cache]! * weight)
        } else {
            relevanceCache[cache]?[course] = User.relevanceCacheWeights[cache]! * weight
        }
    }
    
    func updateRelevanceCache() {
        print("Updating relevance cache...")
        relevanceCache = [
            .plannedSubjects: [:],
            .ratedSubjects: [:],
            .majorSubjects: [:],
            .nonMajorSubjects: [:],
            .primaryRelatedSubjects: [:]
        ]
        
        for course in allCourses {
            addCourse(course, toRelevanceCache: .plannedSubjects)
            for (relatedOne, relevance) in course.relatedSubjects {
                guard let relatedCourse = CourseManager.shared.getCourse(withID: relatedOne) else {
                    continue
                }
                addCourse(relatedCourse, toRelevanceCache: .primaryRelatedSubjects, weight: relevance)
            }
        }
        
        for course in CourseManager.shared.favoriteCourses {
            addCourse(course, toRelevanceCache: .ratedSubjects)
            for (relatedOne, relevance) in course.relatedSubjects {
                guard let relatedCourse = CourseManager.shared.getCourse(withID: relatedOne) else {
                    continue
                }
                addCourse(relatedCourse, toRelevanceCache: .primaryRelatedSubjects, weight: relevance)
            }
        }
        
        for courseOfStudy in coursesOfStudy {
            guard let reqList = RequirementsListManager.shared.requirementList(withID: courseOfStudy) else {
                continue
            }
            for reqCourse in reqList.requiredCourses {
                if reqList.listID.contains("major") {
                    addCourse(reqCourse, toRelevanceCache: .majorSubjects)
                } else {
                    addCourse(reqCourse, toRelevanceCache: .nonMajorSubjects)
                }
                for (relatedOne, relevance) in reqCourse.relatedSubjects {
                    guard let relatedCourse = CourseManager.shared.getCourse(withID: relatedOne) else {
                        continue
                    }
                    addCourse(relatedCourse, toRelevanceCache: .primaryRelatedSubjects, weight: relevance)
                }
            }
        }
        print("Finished updating relevance cache.")
    }
    
    /**
     Returns a multiplier indicating the relevance of the given course to the user.
     If the course has no relevant connections to the user, this function returns
     1.0. Otherwise, the return value is doubled for every connection to the user
     (contained within CourseRoad, related to such a course, within major, and
     within minor).
     */
    func userRelevance(for course: Course) -> Float {
        var relevance: Float = 1.0
        if relevanceCache.count == 0 {
            updateRelevanceCache()
        }
        for (_, courseSet) in relevanceCache {
            if let weight = courseSet[course] {
                relevance *= weight
            }
        }
        return relevance
    }
    
    func userRecommendedCourses() -> [Course] {
        updateRelevanceCache()
        var courseRelevances: [Course: Float] = [:]
        for (_, courseSet) in relevanceCache {
            for (course, relevance) in courseSet {
                guard !allCourses.contains(course) else {
                    continue
                }
                if courseRelevances[course] != nil {
                    courseRelevances[course]? += relevance
                } else {
                    courseRelevances[course] = relevance
                }
            }
        }
        return courseRelevances.sorted(by: { $0.value > $1.value })[0..<min(courseRelevances.count, 15)].map({ $0.key })
    }
    
    // MARK: - Ratings
    
    func setBaselineRatings() {
        var newRatings: [String: Int] = [:]
        for course in allCourses {
            if CourseManager.shared.userRatings[course.subjectID!] == nil {
                newRatings[course.subjectID!] = SubjectRating.baselineInCourseroad
            }
        }
        for listID in coursesOfStudy {
            guard let reqList = RequirementsListManager.shared.requirementList(withID: listID) else {
                continue
            }
            for course in reqList.requiredCourses where course.subjectID != nil {
                if CourseManager.shared.userRatings[course.subjectID!] == nil, newRatings[course.subjectID!] == nil {
                    newRatings[course.subjectID!] = SubjectRating.baselineInCourseOfStudy
                }
            }
        }
        CourseManager.shared.setUserRatings(newRatings, autoGenerated: true)
    }
    
    // MARK: - File Handling
    
    func setNeedsSave() {
        needsSave = true
        warningsCache.removeAll()
        relevanceCache = [:]
    }
    
    var subjectComponentSeparator = "#,#"
    
    func readUserCourses(from file: String) throws {
        self.filePath = file
        let contents = try String(contentsOfFile: file)
        var lines = contents.components(separatedBy: "\n")
        guard lines.count >= 2 else {
            print("No information in this file to read")
            return
        }
        
        // First line, header information
        let firstLine = lines.removeFirst()
        let firstLineComps = firstLine.components(separatedBy: ";")
        guard firstLineComps.count >= 2 else {
            print("First line doesn't have enough information")
            return
        }
        name = firstLineComps[0].trimmingCharacters(in: .whitespacesAndNewlines)
        coursesOfStudy = firstLineComps[1].components(separatedBy: ",")
        
        // Do nothing with the second line for now
        lines.removeFirst()
        
        selectedSubjects = [:]
        overrides = [:]
        for subjectLine in lines where subjectLine.count > 0 {
            let comps = subjectLine.components(separatedBy: subjectComponentSeparator)
            guard comps.count >= 4 else {
                print("Not enough components in subject line \(subjectLine)")
                continue
            }
            guard let semesterRaw = Int(comps[0]),
                let semester = UserSemester(rawValue: semesterRaw),
                let units = Int(comps[3]) else {
                    print("Invalid integer format in subject line \(subjectLine)")
                    continue
            }
            let subjectID = comps[1]
            
            if CourseManager.shared.getCourse(withID: subjectID) == nil {
                CourseManager.shared.addCourse(withID: subjectID, title: comps[2], units: units)
            }
            guard let course = CourseManager.shared.getCourse(withID: subjectID) else {
                print("Unable to add course with ID \(subjectID) to course manager")
                continue
            }
            
            add(course, toSemester: semester)
            
            if comps.count >= 5,
                let override = Int(comps[4]) {
                overrides[course] = (override >= 1)
            }
        }
        
        if !CourseManager.shared.isLoaded {
            NotificationCenter.default.addObserver(self, selector: #selector(courseManagerFinishedLoading), name: .CourseManagerFinishedLoading, object: nil)
        }
    }
    
    private var currentlyWriting = false
    
    func writeUserCourses(to file: String) throws {
        guard !readOnly else {
            return
        }
        
        currentlyWriting = true
        
        var contentsString = ""
        // First line, header information
        contentsString += "\(name);\(coursesOfStudy.joined(separator: ","))\n"
        // Second line, future header information
        contentsString += "\n"
        // Subsequent lines, selected subjects
        for (semester, subjects) in selectedSubjects.sorted(by: { $0.key.rawValue < $1.key.rawValue }) {
            for subject in subjects {
                guard let id = subject.subjectID,
                    let title = subject.subjectTitle else {
                        print("No information to write for \(subject)")
                        continue
                }
                let units = subject.totalUnits
                contentsString += ["\(semester.rawValue)", id, title, "\(units)", overridesWarnings(for: subject) ? "1" : "0"].joined(separator: subjectComponentSeparator) + "\n"
            }
        }
        
        if !FileManager.default.fileExists(atPath: file) {
            let success = FileManager.default.createFile(atPath: file, contents: nil, attributes: nil)
            if !success {
                print("Failed to create file at \(file)")
            }
        }
        try contentsString.write(toFile: file, atomically: true, encoding: .utf8)
        currentlyWriting = false
    }
    
    func autosave() {
        guard needsSave, let path = filePath else {
            return
        }
        
        DispatchQueue.global().async { [weak self] in
            guard let `self` = self,
                !self.currentlyWriting else {
                return
            }
            self.setBaselineRatings()
            do {
                try self.writeUserCourses(to: path)
            } catch {
                print("Error writing file: \(error)")
            }
            self.needsSave = false
        }
    }
    
    // MARK: - Thumbnail Generation
    
    private static let thumbnailDimension: CGFloat = 30.0
    
    private func colorProportionsForThumbnail() -> [(UIColor, CGFloat)] {
        var departmentProportions: [String: CGFloat] = [:]
        for course in allCourses {
            guard let code = course.subjectCode else {
                continue
            }
            if departmentProportions[code] != nil {
                departmentProportions[code]? += 1.0
            } else {
                departmentProportions[code] = 1.0
            }
        }
        if departmentProportions.count > 4 {
            let newProportions = departmentProportions.filter({ $0.value > 1.0 })
            if newProportions.count > 2 {
                departmentProportions = newProportions
            }
        }
        let total = departmentProportions.values.reduce(CGFloat(0.0), +)
        let props = departmentProportions.sorted(by: { $0.key.lexicographicallyPrecedes($1.key) }).map({ (CourseManager.shared.color(forDepartment: $0.key), $0.value / total) })
        if props.count > 0 {
            return props
        } else {
            return [(UIColor.gray, 1.0)]
        }
    }
    
    private func cropThumbnailImage(_ image: UIImage) -> UIImage? {
        let size = CGSize(width: User.thumbnailDimension, height: User.thumbnailDimension)
        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
        let bounds = CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height)
        defer { UIGraphicsEndImageContext() }
        UIBezierPath(roundedRect: bounds, cornerRadius: size.width * 0.2).addClip()
        image.draw(in: bounds.insetBy(dx: (size.width - image.size.width) / 2.0, dy: (size.height - image.size.height / 2.0)))
        return UIGraphicsGetImageFromCurrentImageContext()
    }
    
    func emptyThumbnailImage() -> UIImage? {
        let size = CGSize(width: User.thumbnailDimension, height: User.thumbnailDimension)
        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
        let bounds = CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height)
        defer { UIGraphicsEndImageContext() }
        return UIGraphicsGetImageFromCurrentImageContext()
    }
    
    func generateThumbnailImage() -> UIImage? {
        let startImageSize = CGSize(width: User.thumbnailDimension * 2.0, height: User.thumbnailDimension * 2.0)
        UIGraphicsBeginImageContextWithOptions(startImageSize, false, 0.0)
        // Draw radial pie slices
        guard let context = UIGraphicsGetCurrentContext() else {
            return nil
        }
        let radius = startImageSize.width
        let center = CGPoint(x: startImageSize.width / 2.0, y: startImageSize.width / 2.0)
        context.translateBy(x: center.x, y: center.y)
        context.rotate(by: CGFloat.pi / 4.0)
        context.translateBy(x: -center.x, y: -center.y)
        let proportions = colorProportionsForThumbnail()
        var currentAngle: CGFloat = 0.0
        for (color, prop) in proportions {
            context.setFillColor(color.cgColor)
            let newAngle = currentAngle + prop * 2.0 * CGFloat.pi
            if prop < 0.999 {
                context.move(to: center)
                context.addArc(center: center, radius: radius, startAngle: currentAngle, endAngle: newAngle, clockwise: false)
                context.addLine(to: center)
                context.fillPath()
            } else {
                context.fill(CGRect(x: center.x - radius, y: center.y - radius, width: radius * 2.0, height: radius * 2.0))
            }
            currentAngle = newAngle
        }
        
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        guard image != nil else {
            return nil
        }
        
        // Blur the gradient
        let imageToBlur = CIImage(image: image!)
        guard let blurFilter = CIFilter(name: "CIGaussianBlur") else {
            print("No blur filter")
            return nil
        }
        blurFilter.setValue(imageToBlur, forKey: "inputImage")
        blurFilter.setValue(5.0, forKey: "inputRadius")
        guard let resultImage = blurFilter.value(forKey: "outputImage") as? CIImage else {
            return nil
        }
        let blurredImage = UIImage(ciImage: resultImage)
        
        // Crop to rounded rectangle
        return cropThumbnailImage(blurredImage)
    }
}
